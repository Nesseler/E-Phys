#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
collection of functions that load specific data

Created on Wed Sep 20 15:02:47 2023

@author: moritznesseler
"""

import pandas as pd
import scipy as sc
import matplotlib.pyplot as plt
import numpy as np
from useful_functions import calc_time_series, butter_filter, bessel_filter

# %%

#def load_mat2df(file_path):

#test = sc.io.loadmat('/Users/moritznesseler/test_data/AMY-20230905-E004-cc_IF_06.mat')
test = sc.io.loadmat('C:/Users/nesseler/local E-Phys/AMY-20230905-E004-cc_IF_06.mat')


# %%

all_header = list(test.keys())

traces_header = [key for key in all_header if 'Trace' in key]

voltage_headers = [key for key in traces_header if key[-1] == '1']


#create two dataframe with voltage, current, time


#for v_head in voltage_headers:
#    print(v_head)

test3 = np.transpose(test['Trace_2_6_20_1'])

test4 = np.concatenate((np.transpose(test['Trace_2_6_20_1'])[1], np.transpose(test['Trace_2_6_21_1'])[1]))

plt.plot(test4)


plt.show()

# %%

# build dataframe

potential_df = pd.DataFrame()
current_df = pd.DataFrame()
time_in_ms_df = pd.DataFrame()

for i in range(45):
    current_df[i] = pd.DataFrame(np.transpose(test['Trace_2_6_' + str(i+1) + '_2'])[1])
    potential_df[i] = pd.DataFrame(np.transpose(test['Trace_2_6_' + str(i+1) + '_1'])[1])
    time_in_ms_df[i] = pd.DataFrame(np.transpose(test['Trace_2_6_' + str(i+1) + '_1'])[0])

    



# %%



step20 = np.transpose(test['Trace_2_6_35_1'])[1]

def step_measurements_subplots(mem_pot):

    #convert V to mV
    mem_pot = mem_pot * 10**3
        
    #250ms pre & post pulse at 20 kHz Sampling Rate
    #indices are 0-5000, 5001-25000, 25001-30000
    
    #sampling rate in Hz
    SR = 20000
    
    #pre, post, and pulse duration in s
    pre_post_dur = 0.250
    pulse_dur = 1
    
    pre_idx = np.arange(0, int(pre_post_dur * SR))
    pulse_idx = np.arange(pre_idx[-1]+1, int((pre_post_dur + pulse_dur) * SR))
    post_idx = np.arange(pulse_idx[-1]+1, int((pre_post_dur + pulse_dur + pre_post_dur) * SR))
    
    ylimits = [-100, +20]
    
    bin_width = 5
    
    
    pulse_mean = np.mean(mem_pot[pulse_idx])
    pulse_median = np.median(mem_pot[pulse_idx])
    
    pulse_std = np.std(mem_pot[pulse_idx])
    
    n_hist, bins_hist = np.histogram(mem_pot[pulse_idx], 
                                     bins = np.arange(-100, +20, bin_width))
    
    
    threshold = -20
    
    
    threshold_figure, axs = plt.subplots(1,3, sharey = 'row', 
                                         gridspec_kw={'width_ratios': [0.8, 0.1, 0.1]},
                                         layout = 'constrained')
    
    threshold_figure.set_constrained_layout_pads(wspace=0.0, w_pad=0.0)
    
    axs[0].plot(mem_pot,
                  label = 'cc_IF',
                  linewidth = 0.5)
    axs[0].set_ylim(ylimits)
    axs[0].set_xlim([0, post_idx[-1]])
    axs[0].fill_between(x = pulse_idx, 
                          y1 = ylimits[0],
                          y2 = ylimits[1],
                          color = 'grey',
                          alpha = 0.2,
                          label = 'Analysed time frame')
    axs[0].set_xlabel('Time [ms]')
    axs[0].set_ylabel('Voltage [mV]')
    axs[0].hlines(threshold,
                    xmin = 0,
                    xmax = post_idx[-1],
                    color = 'magenta',
                    label = 'threshold')
    
    axs[1].barh(bins_hist[:-1], 
                  n_hist, 
                  height = bin_width, 
                  align = 'edge',
                  label = 'All points histogram')
    
    hist_max_points = int(pulse_dur * SR)
    
    axs[1].tick_params(axis = 'y', size = 0)
    axs[1].set_xlim([0, hist_max_points])
    axs[1].set_xticklabels([])
    
    
    
    axs[2].set_xlim([0, hist_max_points])
    axs[2].plot(pulse_idx,
                [pulse_mean]*(len(pulse_idx)),
                color = 'red')
    
    axs[2].fill_between(x = pulse_idx, 
                        y1 = [pulse_mean-pulse_std*2]*(len(pulse_idx)),
                        y2 = [pulse_mean+pulse_std*2]*(len(pulse_idx)),
                        color = 'grey',
                        alpha = 0.5,
                        label = '2 std around median')
    
    axs[2].fill_between(x = pulse_idx, 
                        y1 = [pulse_mean-pulse_std]*(len(pulse_idx)),
                        y2 = [pulse_mean+pulse_std]*(len(pulse_idx)),
                        color = 'grey',
                        alpha = 0.7,
                        label = 'Std around median')
    
    #axs[2].tick_params(axis = 'y', size = 0)
    axs[2].set_xticklabels([])
    axs[2].set_xlim([0, post_idx[-1]])
    
    #threshold_figure.legend(loc = 'outside')
    
    plt.rcParams['axes.grid'] = True
    
    plt.show()

step_measurements_subplots(potential_df[30])


# %%

for i in range(44):

    step_measurements_subplots(potential_df[i])
    
    plt.pause(0.1)
    
    print(i)


    
    
# %%  

pulse_df = pd.DataFrame()

mean_ls = []

for i in range(44):
    #sampling rate in Hz
    SR = 20000
    
    #pre, post, and pulse duration in s
    pre_post_dur = 0.250
    pulse_dur = 1
    
    pre_idx = np.arange(0, int(pre_post_dur * SR))
    pulse_idx = np.arange(pre_idx[-1]+1, int((pre_post_dur + pulse_dur) * SR))
    post_idx = np.arange(pulse_idx[-1]+1, int((pre_post_dur + pulse_dur + pre_post_dur) * SR))
    
    ylimits = [-100, +20]
    
    mean_ls.append(np.mean(potential_df[i][pulse_idx]))


    
pulse_df['mean'] = pd.DataFrame(mean_ls)

pulse_df['mean'].plot()





# %%


peak_times = []
inj_cur = []
n_peaks = []
mean_ISI = []

SR = 20 * 1e3

for i in range(45):
    mV = potential_df[i] * 1e3
    
    ipeaks = sc.signal.find_peaks(mV[pulse_idx], prominence = 20)[0] / (SR / 1e3)
    
    peak_times.append(ipeaks)

    inj_cur.append((np.mean(current_df[i].iloc[pulse_idx]) - np.mean(current_df[i].iloc[pre_idx]))*1e12)

    n_peaks.append(len(ipeaks))

    if len(ipeaks) > 1: 
        mean_ISI.append(np.mean(np.diff(ipeaks)))
    else:
        mean_ISI.append(np.nan)




IF_fig, IF_axs = plt.subplots(1,3, sharey='row',
                              gridspec_kw={'width_ratios': [0.7, 0.2, 0.1]},
                              layout = 'constrained')


IF_axs[0].eventplot(peak_times, orientation = 'horizontal', lineoffsets=inj_cur, linelengths=5, color = "w")
IF_axs[0].set_xlim([0, 1000])
IF_axs[0].set_xlabel('Time\n[ms]')


IF_axs[1].plot(n_peaks, inj_cur, color='w')
IF_axs[1].set_xlabel('AP. freq\n[Hz]')
IF_axs[1].set_xlim([0, 75])


IF_axs[2].plot(mean_ISI, inj_cur, color='r')
IF_axs[2].set_xlabel('Mean ISI\n[ms]')
IF_axs[2].set_xlim([0, 100])


IF_axs[0].set_ylim([-20, 200])
IF_fig.supylabel('Injected current [pA]')


plt.show()


# %%

test_step_idx = 1

first_step = potential_df[test_step_idx] * 1e3 

first_step = butter_filter(first_step, 5, 1e3, 20e3)


x_data = np.arange(2000+1)

curve_idx = x_data + 5000

curve = first_step[curve_idx]





plt.plot(x_data, curve)

#plt.xlim([4900, 7000])


def exp_func(x, a, b, c):
    return a * np.exp(-b * x) + c


popt, pcov = sc.optimize.curve_fit(exp_func, x_data, curve, p0=[10, 0.005, -90]) #, bounds=(0, [3., 1., 0.5]))

popt_guess = [10, 0.005, -90]

fit = []

for i in range(len(x_data)):
    fit.append(exp_func(x_data[i], *popt_guess))

plt.plot(x_data, fit, 'g--')
plt.plot(x_data, exp_func(x_data, *popt), 'r--')





#R_input = ∆U/∆I
#∆U = a = popt[0], ∆I = 20 (for first step)

R_input = ( -popt[0] / inj_cur[test_step_idx] ) * 1e3 #in MOhm

print(R_input)


# %%

## ToDO ##

# plot IF function
    # include this function in the raster plot figure
    # 2 functions:
        # calculates IF and returns injected current and spike times
        # one function plots the IF
# finish R input / tau mem



# %%














































